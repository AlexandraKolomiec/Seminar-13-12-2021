# Git 

Что такое git

__Git__ (произносится «гит») — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.

Обычно вы получаете репозиторий Git одним из двух способов:

1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git,

 либо

2. Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

## Создание репозитория в существующем каталоге ##

Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:

для Windows:

    $ cd C:/Users/user/my_project

а затем выполните команду:

    $ git init

## Базовые команды ##
### **git init** — создание репозитория. ### 
Команда git init создает в директории пустой репозиторий в виде директории .git, где и будет в дальнейшем храниться вся информация об истории коммитов, тегах — о ходе разработки проекта:

mkdir project-dir

cd project-dir

git init

### **git add и git rm** — индексация изменений. ###
Следующее, что нужно знать — команда git add. Она позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит.
Индексирует измененный файл, либо оповещение о создании нового:

_git add EDITEDFILE_. 
Вносит в индекс все изменения, включая новые файлы:
git add .


Из индекса и дерева проекта одновременно файл можно удалить командой **git rm**.


Удаляет из индекса и дерева проекта отдельные файлы:
_git rm FILE1 FILE2_


Хороший пример удаления из документации к git, удаляются сразу все файлы txt из папки:
_git rm Documentation/\*.txt_


Вносит в индекс все удаленные файлы:
_git rm -r --cached_.


Сбросить весь индекс или удалить из него изменения определенного файла можно командой **git reset**:
### **git reset** ###

Удаляет из индекса конкретный файл:
_git reset — EDITEDFILE_


Команда git reset используется не только для сбрасывания индекса, поэтому дальше ей будет уделено гораздо больше внимания.

### **git status**  — состояние проекта, измененные и не добавленные файлы, индексированные файлы.

Команду git status, пожалуй, можно считать самой часто используемой наряду с командами коммита и индексации. Она выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки; отдельно выводятся внесенные в индекс и неиндексированные файлы. Использовать ее крайне просто:
git status

Кроме того, git status указывает на файлы с неразрешенными конфликтами слияния и файлы, игнорируемые git.

### **git commit** — совершение коммита

Коммит — базовое понятие во всех системах контроля версий, поэтому совершаться он должен легко и по возможности быстро. В простейшем случае достаточно после индексации набрать:
git commit

Если индекс не пустой, то на его основе будет совершен коммит, после чего пользователя попросят прокомментировать вносимые изменения вызовом команды **edit**. 
Сохраняемся, и вуаля! Коммит готов.

 Есть несколько ключей, упрощающих работу с git commit:


Совершает коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено:
_git commit -a_


Комментирует коммит прямо из командной строки вместо текстового редактора:
_git commit -m «commit comment»_


Вносит в индекс и создаёт коммит на основе изменений единственного файла:
_git commit FILENAME_


Пример написания хорошего сообщения коммита:
Описывает изменение (до 50 символов).
Более детальное объяснение, если необходимо. Перенос на 72 символе или около того. В некоторых контекстах первая строка рассматривается как тема письма, а остальное как тело. Пустая строка, отделяющая сводку
от тела, важна (если вы не опустили тело целиком); если вы оставите их вместе, инструменты, такие как **rebase**, могут воспринять это неправильно.


Дальнейшие параграфы идут после пустых строк

 - также можно применять маркеры списков

 - обычно в качестве маркера списка используется дефис или звёздочка
   с одним пробелом перед ним и пустыми строками между пунктами,
   хотя соглашения в этом аспекте могут разниться

Если вы используете систему отслеживания задач, поставьте ссылки на нее:

Resolves: #123

See also: #456, #789

### **git reset**— возврат к определенному коммиту, откат изменений, «жесткий» или «мягкий».
Помимо работы с индексом (см. выше), git reset позволяет сбросить состояние проекта до какого-либо коммита в истории. В git данное действие может быть двух видов: «мягкого»(soft reset) и «жесткого» (hard reset).

«Мягкий» (с ключом **--soft**) резет оставит нетронутыми ваши индекс и все дерево файлов и директорий проекта, вернется к работе с указанным коммитом. Иными словами, если вы обнаруживаете ошибку в только что совершенном коммите или комментарии к нему, то легко можно исправить ситуацию:
1.	Некорректный коммит
2.	git commit
3.	Переход к работе над уже совершенным коммитом, сохраняя все состояние проекта и проиндексированные файлы
4.	git reset --soft HEAD^
5.	Редактирование файла или файлов
6.	Добавление файлов в индекс
7.	git add .
8.	Возврат к последнему коммиту, будет предложено отредактировать его сообщение
9.	git commit -c ORIG_HEAD

Если сообщение оставить прежним, то достаточно изменить регистр ключа **-с
git commit** **-C ORIG_HEAD**. 
Обратите внимание на обозначение HEAD^, оно означает «обратиться к предку последнего коммита». Подробней описан синтаксис такой относительной адресации будет ниже, в разделе «Хэши, тэги, относительная адресация». Соответственно, HEAD — ссылка на последний коммит. Ссылка ORIG_HEAD после «мягкого» резета указывает на оригинальный коммит.
Естественно, можно вернуться и на большую глубину коммитов,


«Жесткий» резет (ключ **--hard**) — команда, которую следует использовать с осторожностью. _git reset --hard_ вернет дерево проекта и индекс в состояние, соответствующее указанному коммиту, удалив изменения последующих коммитов:

git add .

git commit -m «destined to death»

git reset --hard HEAD~1 — больше никто и никогда не увидит этот позорный коммит...

git reset --hard HEAD~3 — ...вернее, три последних коммита. Никто. Никогда!

Если команда достигнет точки ветвления, удаления коммита не произойдет.
Для команд слияния или выкачивания последних изменений с удаленного репозитория примеры резета будут приведены в соответствующих разделах.

### **git revert** — отмена изменений, произведенных в прошлом отдельным коммитом. 
Возможна ситуация, в которой требуется отменить изменения, внесенные отдельным коммитом. git revert создает новый коммит, накладывающий обратные изменения.

Отменяет коммит, помеченный тегом:
_git revert config-modify-tag_

Отменяет коммит, используя его хэш:
_git revert cgsjd2h_

Для отмены коммита слияния (коммита у которого несколько родителей), необходимо указать хэш и номер одного из родителей коммита:
_git revert cgsjd2h -m 1_

Для использования команды необходимо, чтобы состояние проекта не отличалось от состояния, зафиксированного последним коммитом.

### **git log**— разнообразная информация о коммитах в целом.

Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда git log.
Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):
git log


Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):
_git log -p_


Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом --stat:
_git log --stat_


За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ --summary:
_git log --summary_


Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»):
1. _git log README_


2. или, если версия git не совсем свежая:
_git log — README_


Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):


* git log --since=«1 day 2 hours» README


* git log --since=«2 hours» README


Изменения, касающиеся отдельной папки:
_git log --since=«2 hours» dir/_


Можно отталкиваться от тегов.
Все коммиты, начиная с тега v1:
_git log v1..._


Все коммиты, включающие изменения файла README, начиная с тега v1:
_git log v1... README_


Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:
_git log v1..v2 README_


Интересные возможности по формату вывода команды предоставляет ключ __--pretty__.
Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):
_git log --pretty=oneline_


Лаконичная информация о коммитах, приводятся только автор и комментарий:
_git log --pretty=short_


Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:
_git log --pretty=full/fuller_


В принципе, формат вывода можно определить самостоятельно:
_git log --pretty=format:'FORMAT'_


Определение формата можно поискать в разделе по git log из Git Community Book или справке.

 Красивый ASCII-граф коммитов выводится с использованием ключа __--graph__.


### **git diff**— отличия между деревьями проекта, коммитами и т.д.
Своего рода подмножеством команды git log можно считать команду git diff, определяющую изменения между объектами в проекте - деревьями (файлов и директорий).


Показывает изменения, не внесенные в индекс:
_git diff_


Изменения, внесенные в индекс:
_git diff --cached_


Изменения в проекте по сравнению с последним коммитом:
_git diff HEAD_


Предпоследним коммитом:
_git diff HEAD^_


Можно сравнивать «головы» веток:
_git diff master..experimental_


или активную ветку с какой-либо:
_git diff experimental_


### **git show** — показать изменения, внесенные отдельным коммитом.
Посмотреть изменения, внесенные любым коммитом в истории, можно командой git show:


_git show COMMIT_TAG_

### **git blame и git annotate** — команды, помогающие отслеживать изменения файлов.

При работе в команде часто требуется выяснить, кто именно написал конкретный код. Удобно использовать команду git blame, выводящую построчную информацию о последнем коммите, коснувшемся строки, имя автора и хэш коммита:

_git blame README_


Можно указать и конкретные строки для отображения:
_git blame -L 2,+3 README_ — выведет информацию по трем строкам, начиная со второй.


Аналогично работает команда git annotate, выводящая и строки, и информацию о коммитах, их коснувшихся:


_git annotate README_


### **git grep** — поиск слов по проекту, состоянию проекта в прошлом.
git grep, в целом, просто дублирует функционал знаменитой юниксовой команды. Однако он позволяет слова и их сочетания искать в прошлом проекта, что бывает очень полезно.


Ищет слова tst в проекте:
_git grep tst_


Подсчитывает число упоминаний tst в проекте:
_git grep -с tst_


Ищет в старой версии проекта:
_git grep tst v1_


Команда позволяет использовать логическое И и ИЛИ.
Ищет строки, где упоминаются и первое слово, и второе:
_git grep -e 'first' --and -e 'another'_


Ищет строки, где встречается хотя бы одно из слов:
_git grep --all-match -e 'first' -e 'second'_

# **Ветвление**

### **git branch** — создание, перечисление и удаление веток


Работа с ветками — очень легкая процедура в git, все необходимые механизмы сконцентрированы в одной команде.
Просто перечисляет существующие ветки, отметив активную:
git branch


Создаёт новую ветку new-branch:
_git branch new-branch_


Удаляет ветку, если та была залита (merged) с разрешением возможных конфликтов в текущую:
_git branch -d new-branch_


Удаляет ветку в любом случае:
_git branch -D new-branch_


Переименовывает ветку:
_git branch -m new-name-branch_


Показывывает те ветки, среди предков которых есть определенный коммит:
_git branch --contains v1.2_


Показывает коммит ответвления ветки new-name-branch от ветки master:
_git merge-base master new-name-branch_


### **git checkout** — переключение между ветками, извлечение файлов

Команда git checkout позволяет переключаться между последними коммитами (если упрощенно) веток:
_checkout some-other-branch_


Создаёт ветку, в которую и произойдет переключение:
_git checkout -b some-other-new-branch_


Если в текущей ветке были какие-то изменения по сравнению с последним коммитом в ветке(HEAD), то команда откажется производить переключение, дабы не потерять произведенную работу. Проигнорировать этот факт позволяет ключ **-f**:


_git checkout -f some-other-branch_


В случае, когда изменения надо все же сохранить, следует использовать ключ **-m**. Тогда команда перед переключением попробует залить изменения в текущую ветку и, после разрешения возможных конфликтов переключиться в новую:


_git checkout -m some-other-branch_


Вернуть файл (или просто вытащить из прошлого коммита) позволяет команда вида:
_git checkout somefile_


Возвращает somefile к состоянию последнего коммита:
_git checkout somefile_


Возвращает somefile к состоянию на два коммита назад по ветке:
_git checkout HEAD~2 somefile_


### **git merge** — слияние веток, разрешение возможных конфликтов

Слияние веток, в отличие от обычной практики централизованных систем, в git происходит практически каждый день. Естественно, что имеется удобный интерфейс к популярной операции.


Пытается объединить текующую ветку и ветку new-feature:

_git merge new-feature_


В случае возникновения конфликтов коммита не происходит, а по проблемным файлам расставляются специальные метки а-ля svn; сами же файлы отмечаются в индексе как «не соединенные» (unmerged). До тех пор пока проблемы не будут решены, коммит совершить будет нельзя.

Например, конфликт возник в файле TROUBLE, что можно увидеть в git status.

Произошла неудачная попытка слияния:
git merge experiment

Смотрим на проблемные места:
git status

Разрешаем проблемы:
edit TROUBLE

Индексируем наши изменения, тем самым снимая метки:
git add .

Совершаем коммит слияния:
git commit

Вот и все, ничего сложного. Если в процессе разрешения вы передумали разрешать конфликт, достаточно набрать (это вернёт обе ветки в исходные состояния):

git reset --hard HEAD

Если же коммит слияния был совершен, используем команду:

git reset --hard ORIG_HEAD

